// GENERATED CODE - DO NOT MODIFY BY HAND
// ignore_for_file: deprecated_member_use, deprecated_member_use_from_same_package, use_function_type_syntax_for_parameters, unnecessary_const, avoid_init_to_null, invalid_override_different_default_values_named, prefer_expression_function_bodies

part of 'user_changer_cubit.dart';

// **************************************************************************
// FreezedGenerator
// **************************************************************************

T _$identity<T>(T value) => value;

/// @nodoc
class _$UserChangerStateTearOff {
  const _$UserChangerStateTearOff();

// ignore: unused_element
  UserChangerInitial initial() {
    return const UserChangerInitial();
  }

// ignore: unused_element
  UserChangerLoading loading() {
    return const UserChangerLoading();
  }

// ignore: unused_element
  UserChangerLoaded loaded() {
    return const UserChangerLoaded();
  }

// ignore: unused_element
  UserChangerError error(String message) {
    return UserChangerError(
      message,
    );
  }
}

/// @nodoc
// ignore: unused_element
const $UserChangerState = _$UserChangerStateTearOff();

/// @nodoc
mixin _$UserChangerState {
  @optionalTypeArgs
  TResult when<TResult extends Object>({
    @required TResult initial(),
    @required TResult loading(),
    @required TResult loaded(),
    @required TResult error(String message),
  });
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object>({
    TResult initial(),
    TResult loading(),
    TResult loaded(),
    TResult error(String message),
    @required TResult orElse(),
  });
  @optionalTypeArgs
  TResult map<TResult extends Object>({
    @required TResult initial(UserChangerInitial value),
    @required TResult loading(UserChangerLoading value),
    @required TResult loaded(UserChangerLoaded value),
    @required TResult error(UserChangerError value),
  });
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object>({
    TResult initial(UserChangerInitial value),
    TResult loading(UserChangerLoading value),
    TResult loaded(UserChangerLoaded value),
    TResult error(UserChangerError value),
    @required TResult orElse(),
  });
}

/// @nodoc
abstract class $UserChangerStateCopyWith<$Res> {
  factory $UserChangerStateCopyWith(
          UserChangerState value, $Res Function(UserChangerState) then) =
      _$UserChangerStateCopyWithImpl<$Res>;
}

/// @nodoc
class _$UserChangerStateCopyWithImpl<$Res>
    implements $UserChangerStateCopyWith<$Res> {
  _$UserChangerStateCopyWithImpl(this._value, this._then);

  final UserChangerState _value;
  // ignore: unused_field
  final $Res Function(UserChangerState) _then;
}

/// @nodoc
abstract class $UserChangerInitialCopyWith<$Res> {
  factory $UserChangerInitialCopyWith(
          UserChangerInitial value, $Res Function(UserChangerInitial) then) =
      _$UserChangerInitialCopyWithImpl<$Res>;
}

/// @nodoc
class _$UserChangerInitialCopyWithImpl<$Res>
    extends _$UserChangerStateCopyWithImpl<$Res>
    implements $UserChangerInitialCopyWith<$Res> {
  _$UserChangerInitialCopyWithImpl(
      UserChangerInitial _value, $Res Function(UserChangerInitial) _then)
      : super(_value, (v) => _then(v as UserChangerInitial));

  @override
  UserChangerInitial get _value => super._value as UserChangerInitial;
}

/// @nodoc
class _$UserChangerInitial implements UserChangerInitial {
  const _$UserChangerInitial();

  @override
  String toString() {
    return 'UserChangerState.initial()';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) || (other is UserChangerInitial);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object>({
    @required TResult initial(),
    @required TResult loading(),
    @required TResult loaded(),
    @required TResult error(String message),
  }) {
    assert(initial != null);
    assert(loading != null);
    assert(loaded != null);
    assert(error != null);
    return initial();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object>({
    TResult initial(),
    TResult loading(),
    TResult loaded(),
    TResult error(String message),
    @required TResult orElse(),
  }) {
    assert(orElse != null);
    if (initial != null) {
      return initial();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object>({
    @required TResult initial(UserChangerInitial value),
    @required TResult loading(UserChangerLoading value),
    @required TResult loaded(UserChangerLoaded value),
    @required TResult error(UserChangerError value),
  }) {
    assert(initial != null);
    assert(loading != null);
    assert(loaded != null);
    assert(error != null);
    return initial(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object>({
    TResult initial(UserChangerInitial value),
    TResult loading(UserChangerLoading value),
    TResult loaded(UserChangerLoaded value),
    TResult error(UserChangerError value),
    @required TResult orElse(),
  }) {
    assert(orElse != null);
    if (initial != null) {
      return initial(this);
    }
    return orElse();
  }
}

abstract class UserChangerInitial implements UserChangerState {
  const factory UserChangerInitial() = _$UserChangerInitial;
}

/// @nodoc
abstract class $UserChangerLoadingCopyWith<$Res> {
  factory $UserChangerLoadingCopyWith(
          UserChangerLoading value, $Res Function(UserChangerLoading) then) =
      _$UserChangerLoadingCopyWithImpl<$Res>;
}

/// @nodoc
class _$UserChangerLoadingCopyWithImpl<$Res>
    extends _$UserChangerStateCopyWithImpl<$Res>
    implements $UserChangerLoadingCopyWith<$Res> {
  _$UserChangerLoadingCopyWithImpl(
      UserChangerLoading _value, $Res Function(UserChangerLoading) _then)
      : super(_value, (v) => _then(v as UserChangerLoading));

  @override
  UserChangerLoading get _value => super._value as UserChangerLoading;
}

/// @nodoc
class _$UserChangerLoading implements UserChangerLoading {
  const _$UserChangerLoading();

  @override
  String toString() {
    return 'UserChangerState.loading()';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) || (other is UserChangerLoading);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object>({
    @required TResult initial(),
    @required TResult loading(),
    @required TResult loaded(),
    @required TResult error(String message),
  }) {
    assert(initial != null);
    assert(loading != null);
    assert(loaded != null);
    assert(error != null);
    return loading();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object>({
    TResult initial(),
    TResult loading(),
    TResult loaded(),
    TResult error(String message),
    @required TResult orElse(),
  }) {
    assert(orElse != null);
    if (loading != null) {
      return loading();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object>({
    @required TResult initial(UserChangerInitial value),
    @required TResult loading(UserChangerLoading value),
    @required TResult loaded(UserChangerLoaded value),
    @required TResult error(UserChangerError value),
  }) {
    assert(initial != null);
    assert(loading != null);
    assert(loaded != null);
    assert(error != null);
    return loading(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object>({
    TResult initial(UserChangerInitial value),
    TResult loading(UserChangerLoading value),
    TResult loaded(UserChangerLoaded value),
    TResult error(UserChangerError value),
    @required TResult orElse(),
  }) {
    assert(orElse != null);
    if (loading != null) {
      return loading(this);
    }
    return orElse();
  }
}

abstract class UserChangerLoading implements UserChangerState {
  const factory UserChangerLoading() = _$UserChangerLoading;
}

/// @nodoc
abstract class $UserChangerLoadedCopyWith<$Res> {
  factory $UserChangerLoadedCopyWith(
          UserChangerLoaded value, $Res Function(UserChangerLoaded) then) =
      _$UserChangerLoadedCopyWithImpl<$Res>;
}

/// @nodoc
class _$UserChangerLoadedCopyWithImpl<$Res>
    extends _$UserChangerStateCopyWithImpl<$Res>
    implements $UserChangerLoadedCopyWith<$Res> {
  _$UserChangerLoadedCopyWithImpl(
      UserChangerLoaded _value, $Res Function(UserChangerLoaded) _then)
      : super(_value, (v) => _then(v as UserChangerLoaded));

  @override
  UserChangerLoaded get _value => super._value as UserChangerLoaded;
}

/// @nodoc
class _$UserChangerLoaded implements UserChangerLoaded {
  const _$UserChangerLoaded();

  @override
  String toString() {
    return 'UserChangerState.loaded()';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) || (other is UserChangerLoaded);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object>({
    @required TResult initial(),
    @required TResult loading(),
    @required TResult loaded(),
    @required TResult error(String message),
  }) {
    assert(initial != null);
    assert(loading != null);
    assert(loaded != null);
    assert(error != null);
    return loaded();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object>({
    TResult initial(),
    TResult loading(),
    TResult loaded(),
    TResult error(String message),
    @required TResult orElse(),
  }) {
    assert(orElse != null);
    if (loaded != null) {
      return loaded();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object>({
    @required TResult initial(UserChangerInitial value),
    @required TResult loading(UserChangerLoading value),
    @required TResult loaded(UserChangerLoaded value),
    @required TResult error(UserChangerError value),
  }) {
    assert(initial != null);
    assert(loading != null);
    assert(loaded != null);
    assert(error != null);
    return loaded(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object>({
    TResult initial(UserChangerInitial value),
    TResult loading(UserChangerLoading value),
    TResult loaded(UserChangerLoaded value),
    TResult error(UserChangerError value),
    @required TResult orElse(),
  }) {
    assert(orElse != null);
    if (loaded != null) {
      return loaded(this);
    }
    return orElse();
  }
}

abstract class UserChangerLoaded implements UserChangerState {
  const factory UserChangerLoaded() = _$UserChangerLoaded;
}

/// @nodoc
abstract class $UserChangerErrorCopyWith<$Res> {
  factory $UserChangerErrorCopyWith(
          UserChangerError value, $Res Function(UserChangerError) then) =
      _$UserChangerErrorCopyWithImpl<$Res>;
  $Res call({String message});
}

/// @nodoc
class _$UserChangerErrorCopyWithImpl<$Res>
    extends _$UserChangerStateCopyWithImpl<$Res>
    implements $UserChangerErrorCopyWith<$Res> {
  _$UserChangerErrorCopyWithImpl(
      UserChangerError _value, $Res Function(UserChangerError) _then)
      : super(_value, (v) => _then(v as UserChangerError));

  @override
  UserChangerError get _value => super._value as UserChangerError;

  @override
  $Res call({
    Object message = freezed,
  }) {
    return _then(UserChangerError(
      message == freezed ? _value.message : message as String,
    ));
  }
}

/// @nodoc
class _$UserChangerError implements UserChangerError {
  const _$UserChangerError(this.message) : assert(message != null);

  @override
  final String message;

  @override
  String toString() {
    return 'UserChangerState.error(message: $message)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is UserChangerError &&
            (identical(other.message, message) ||
                const DeepCollectionEquality().equals(other.message, message)));
  }

  @override
  int get hashCode =>
      runtimeType.hashCode ^ const DeepCollectionEquality().hash(message);

  @JsonKey(ignore: true)
  @override
  $UserChangerErrorCopyWith<UserChangerError> get copyWith =>
      _$UserChangerErrorCopyWithImpl<UserChangerError>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object>({
    @required TResult initial(),
    @required TResult loading(),
    @required TResult loaded(),
    @required TResult error(String message),
  }) {
    assert(initial != null);
    assert(loading != null);
    assert(loaded != null);
    assert(error != null);
    return error(message);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object>({
    TResult initial(),
    TResult loading(),
    TResult loaded(),
    TResult error(String message),
    @required TResult orElse(),
  }) {
    assert(orElse != null);
    if (error != null) {
      return error(message);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object>({
    @required TResult initial(UserChangerInitial value),
    @required TResult loading(UserChangerLoading value),
    @required TResult loaded(UserChangerLoaded value),
    @required TResult error(UserChangerError value),
  }) {
    assert(initial != null);
    assert(loading != null);
    assert(loaded != null);
    assert(error != null);
    return error(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object>({
    TResult initial(UserChangerInitial value),
    TResult loading(UserChangerLoading value),
    TResult loaded(UserChangerLoaded value),
    TResult error(UserChangerError value),
    @required TResult orElse(),
  }) {
    assert(orElse != null);
    if (error != null) {
      return error(this);
    }
    return orElse();
  }
}

abstract class UserChangerError implements UserChangerState {
  const factory UserChangerError(String message) = _$UserChangerError;

  String get message;
  @JsonKey(ignore: true)
  $UserChangerErrorCopyWith<UserChangerError> get copyWith;
}
